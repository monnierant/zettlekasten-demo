/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => YTranscriptPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/transcript-view.ts
var import_obsidian2 = require("obsidian");

// src/fetch-transcript.ts
var import_obsidian = require("obsidian");
var YOUTUBE_TITLE_REGEX = new RegExp(/<meta\s+name="title"\s+content="([^"]*)">/);
var YoutubeTranscriptError = class extends Error {
  constructor(err) {
    if (!(err instanceof Error)) {
      super("");
      return;
    }
    if (err.message.includes("ERR_INVALID_URL")) {
      super("Invalid YouTube URL");
    } else {
      super(err.message);
    }
  }
};
var YoutubeTranscript = class {
  static async fetchTranscript(url, config) {
    try {
      const videoPageBody = await (0, import_obsidian.request)(url);
      const titleMatch = videoPageBody.match(YOUTUBE_TITLE_REGEX);
      let title = "";
      if (titleMatch)
        title = titleMatch[1];
      const innerTubeApiKey = videoPageBody.split('"INNERTUBE_API_KEY":"')[1].split('"')[0];
      if (innerTubeApiKey && innerTubeApiKey.length > 0) {
        const response = await (0, import_obsidian.requestUrl)({
          url: `https://www.youtube.com/youtubei/v1/get_transcript?key=${innerTubeApiKey}`,
          method: "POST",
          body: JSON.stringify(this.generateRequest(videoPageBody.toString(), config))
        });
        const body = response.json;
        if (body.responseContext) {
          if (!body.actions) {
            throw new Error("Transcript is disabled on this video");
          }
          const transcripts = body.actions[0].updateEngagementPanelAction.content.transcriptRenderer.body.transcriptBodyRenderer.cueGroups;
          return {
            title,
            lines: transcripts.map((cue) => ({
              text: cue.transcriptCueGroupRenderer.cues[0].transcriptCueRenderer.cue.simpleText,
              duration: parseInt(cue.transcriptCueGroupRenderer.cues[0].transcriptCueRenderer.durationMs),
              offset: parseInt(cue.transcriptCueGroupRenderer.cues[0].transcriptCueRenderer.startOffsetMs)
            }))
          };
        }
      }
    } catch (err) {
      throw new YoutubeTranscriptError(err);
    }
  }
  static generateRequest(page, config) {
    var _a, _b, _c, _d;
    const params = (_a = page.split('"serializedShareEntity":"')[1]) == null ? void 0 : _a.split('"')[0];
    const visitorData = (_b = page.split('"VISITOR_DATA":"')[1]) == null ? void 0 : _b.split('"')[0];
    const sessionId = (_c = page.split('"sessionId":"')[1]) == null ? void 0 : _c.split('"')[0];
    let clickTrackingParams = (_d = page == null ? void 0 : page.split('"clickTrackingParams":"')[1]) == null ? void 0 : _d.split('"')[0];
    clickTrackingParams = clickTrackingParams.slice(0, 28);
    return {
      context: {
        client: {
          hl: (config == null ? void 0 : config.lang) || "fr",
          gl: (config == null ? void 0 : config.country) || "FR",
          visitorData,
          userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36,gzip(gfe)",
          clientName: "WEB",
          clientVersion: "2.20200925.01.00",
          osName: "Macintosh",
          osVersion: "10_15_4",
          browserName: "Chrome",
          browserVersion: "85.0f.4183.83",
          screenWidthPoints: 1440,
          screenHeightPoints: 770,
          screenPixelDensity: 2,
          utcOffsetMinutes: 120,
          userInterfaceTheme: "USER_INTERFACE_THEME_LIGHT",
          connectionType: "CONN_CELLULAR_3G"
        },
        request: {
          sessionId,
          internalExperimentFlags: [],
          consistencyTokenJars: []
        },
        user: {},
        clientScreenNonce: this.generateNonce(),
        clickTracking: {
          clickTrackingParams: decodeURI(clickTrackingParams)
        }
      },
      params
    };
  }
  static generateNonce() {
    const rnd = Math.random().toString();
    const alphabet = "ABCDEFGHIJKLMOPQRSTUVWXYZabcdefghjijklmnopqrstuvwxyz0123456789";
    const jda = [
      alphabet + "+/=",
      alphabet + "+/",
      alphabet + "-_=",
      alphabet + "-_.",
      alphabet + "-_"
    ];
    const b = jda[3];
    const a = [];
    for (let i = 0; i < rnd.length - 1; i++) {
      a.push(rnd[i].charCodeAt(i));
    }
    let c = "";
    let d = 0;
    let m, n, q, r, f, g;
    while (d < a.length) {
      f = a[d];
      g = d + 1 < a.length;
      if (g) {
        m = a[d + 1];
      } else {
        m = 0;
      }
      n = d + 2 < a.length;
      if (n) {
        q = a[d + 2];
      } else {
        q = 0;
      }
      r = f >> 2;
      f = (f & 3) << 4 | m >> 4;
      m = (m & 15) << 2 | q >> 6;
      q &= 63;
      if (!n) {
        q = 64;
        if (!q) {
          m = 64;
        }
      }
      c += b[r] + b[f] + b[m] + b[q];
      d += 3;
    }
    return c;
  }
};

// src/timestampt-utils.ts
var formatTimestamp = (t) => {
  if (t < 0)
    return "00:00";
  const fnum = (n) => `${n | 0}`.padStart(2, "0");
  const s = 1e3;
  const m = 60 * s;
  const h = 60 * m;
  const hours = Math.floor(t / h);
  const minutes = Math.floor((t - hours * h) / m);
  const seconds = Math.floor((t - hours * h - minutes * m) / s);
  const time = hours ? [hours, minutes, seconds] : [minutes, seconds];
  return time.map(fnum).join(":");
};

// src/render-utils.ts
var highlightText = (div, searchValue) => {
  const content = div.innerHTML;
  const highlightedContent = content.replace(new RegExp(searchValue, "gi"), '<span class="yt-transcript__highlight">$&</span>');
  div.innerHTML = highlightedContent;
};
var getTranscriptBlocks = (data, timestampMod) => {
  const transcriptBlocks = [];
  let quote = "";
  let quoteTimeOffset = 0;
  data.forEach((line, i) => {
    if (i === 0) {
      quoteTimeOffset = line.offset;
      quote += line.text + " ";
      return;
    }
    if (i % timestampMod == 0) {
      transcriptBlocks.push({
        quote,
        quoteTimeOffset
      });
      quote = "";
      quoteTimeOffset = line.offset;
    }
    quote += line.text + " ";
  });
  if (quote !== "") {
    transcriptBlocks.push({
      quote,
      quoteTimeOffset
    });
  }
  return transcriptBlocks;
};

// src/transcript-view.ts
var TRANSCRIPT_TYPE_VIEW = "transcript-view";
var TranscriptView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.videoData = [];
    this.plugin = plugin;
    this.isDataLoaded = false;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h4", { text: "Transcript" });
  }
  async onClose() {
    const leafIndex = this.getLeafIndex();
    this.plugin.settings.leafUrls.splice(leafIndex, 1);
  }
  getLeafIndex() {
    const leaves = this.app.workspace.getLeavesOfType(TRANSCRIPT_TYPE_VIEW);
    return leaves.findIndex((leaf) => leaf === this.leaf);
  }
  renderLoader() {
    if (this.loaderContainerEl !== void 0) {
      this.loaderContainerEl.createEl("div", {
        text: "Loading..."
      });
    }
  }
  renderSearchInput(url, data, timestampMod) {
    const searchInputEl = this.contentEl.createEl("input");
    searchInputEl.type = "text";
    searchInputEl.placeholder = "Search...";
    searchInputEl.style.marginBottom = "20px";
    searchInputEl.addEventListener("input", (e) => {
      const searchFilter = e.target.value;
      this.renderTranscriptionBlocks(url, data, timestampMod, searchFilter);
    });
  }
  renderVideoTitle(title) {
    const titleEl = this.contentEl.createEl("div");
    titleEl.innerHTML = title;
    titleEl.style.fontWeight = "bold";
    titleEl.style.marginBottom = "20px";
  }
  formatContentToPaste(url, blocks) {
    return blocks.map((block) => {
      const { quote, quoteTimeOffset } = block;
      const href = url + "&t=" + Math.floor(quoteTimeOffset / 1e3);
      const formattedBlock = `[${formatTimestamp(quoteTimeOffset)}](${href}) ${quote}`;
      return formattedBlock;
    }).join("\n");
  }
  renderTranscriptionBlocks(url, data, timestampMod, searchValue) {
    const dataContainerEl = this.dataContainerEl;
    if (dataContainerEl !== void 0) {
      dataContainerEl.empty();
      const transcriptBlocks = getTranscriptBlocks(data.lines, timestampMod);
      const filteredBlocks = transcriptBlocks.filter((block) => block.quote.toLowerCase().includes(searchValue.toLowerCase()));
      filteredBlocks.forEach((block) => {
        const { quote, quoteTimeOffset } = block;
        const blockContainerEl = createEl("div", {
          cls: "yt-transcript__transcript-block"
        });
        blockContainerEl.draggable = true;
        const linkEl = createEl("a", {
          text: formatTimestamp(quoteTimeOffset),
          attr: {
            href: url + "&t=" + Math.floor(quoteTimeOffset / 1e3)
          }
        });
        linkEl.style.marginBottom = "5px";
        const span = dataContainerEl.createEl("span", {
          text: quote,
          title: "Click to copy"
        });
        span.addEventListener("click", (event) => {
          var _a;
          const target = event.target;
          if (target !== null) {
            navigator.clipboard.writeText((_a = target.textContent) != null ? _a : "");
          }
        });
        if (searchValue !== "")
          highlightText(span, searchValue);
        blockContainerEl.appendChild(linkEl);
        blockContainerEl.appendChild(span);
        blockContainerEl.addEventListener("dragstart", (event) => {
          var _a;
          (_a = event.dataTransfer) == null ? void 0 : _a.setData("text/html", blockContainerEl.innerHTML);
        });
        blockContainerEl.addEventListener("contextmenu", (event) => {
          const menu = new import_obsidian2.Menu();
          menu.addItem((item) => item.setTitle("Copy all").onClick(() => {
            navigator.clipboard.writeText(this.formatContentToPaste(url, filteredBlocks));
          }));
          menu.showAtPosition({
            x: event.clientX,
            y: event.clientY
          });
        });
        dataContainerEl.appendChild(blockContainerEl);
      });
    }
  }
  async setEphemeralState(state) {
    var _a;
    if (this.isDataLoaded)
      return;
    const leafIndex = this.getLeafIndex();
    if (state.url) {
      this.plugin.settings.leafUrls[leafIndex] = state.url;
      await this.plugin.saveSettings();
    }
    const { lang, country, timestampMod, leafUrls } = this.plugin.settings;
    const url = leafUrls[leafIndex];
    try {
      if (this.loaderContainerEl === void 0) {
        this.loaderContainerEl = this.contentEl.createEl("div");
      } else {
        this.loaderContainerEl.empty();
      }
      this.renderLoader();
      const data = await YoutubeTranscript.fetchTranscript(url, {
        lang,
        country
      });
      if (!data)
        throw Error();
      this.isDataLoaded = true;
      this.loaderContainerEl.empty();
      this.renderVideoTitle(data.title);
      this.renderSearchInput(url, data, timestampMod);
      if (this.dataContainerEl === void 0) {
        this.dataContainerEl = this.contentEl.createEl("div");
      } else {
        this.dataContainerEl.empty();
      }
      if (this.errorContainerEl !== void 0) {
        this.errorContainerEl.empty();
      }
      if (data.lines.length === 0) {
        this.dataContainerEl.createEl("h4", {
          text: "No transcript found"
        });
        this.dataContainerEl.createEl("div", {
          text: "Please check if video contains any transcript or try adjust language and country in plugin settings."
        });
      } else {
        this.renderTranscriptionBlocks(url, data, timestampMod, "");
      }
    } catch (err) {
      let errorMessage = "";
      if (err instanceof YoutubeTranscriptError) {
        errorMessage = err.message;
      }
      (_a = this.loaderContainerEl) == null ? void 0 : _a.empty();
      if (this.errorContainerEl === void 0) {
        this.errorContainerEl = this.contentEl.createEl("h5");
      } else {
        this.errorContainerEl.empty();
      }
      const titleEl = this.errorContainerEl.createEl("div", {
        text: "Error loading transcript"
      });
      titleEl.style.marginBottom = "5px";
      const messageEl = this.errorContainerEl.createEl("div", {
        text: errorMessage
      });
      messageEl.style.color = "var(--text-muted)";
      messageEl.style.fontSize = "var(--font-ui-small)";
    }
  }
  getViewType() {
    return TRANSCRIPT_TYPE_VIEW;
  }
  getDisplayText() {
    return "YouTube Transcript";
  }
  getIcon() {
    return "scroll";
  }
};

// src/prompt-modal.ts
var import_obsidian3 = require("obsidian");
var PromptModal = class extends import_obsidian3.Modal {
  constructor() {
    super(app);
    this.submitted = false;
  }
  listenInput(evt) {
    if (evt.key === "Enter") {
      evt.preventDefault();
      this.enterCallback(evt);
    }
  }
  onOpen() {
    this.titleEl.setText("YouTube URL");
    this.createForm();
  }
  onClose() {
    this.contentEl.empty();
    if (!this.submitted) {
      this.reject();
    }
  }
  createForm() {
    const textInput = new import_obsidian3.TextComponent(this.contentEl);
    textInput.inputEl.style.width = "100%";
    textInput.onChange((value) => this.value = value);
    textInput.inputEl.addEventListener("keydown", (evt) => this.enterCallback(evt));
    textInput.inputEl.focus();
    const buttonDiv = this.modalEl.createDiv();
    buttonDiv.addClass("modal-button-container");
    const submitButton = new import_obsidian3.ButtonComponent(buttonDiv);
    submitButton.buttonEl.addClass("mod-cta");
    submitButton.setButtonText("Submit").onClick((evt) => {
      this.resolveAndClose(evt);
    });
  }
  enterCallback(evt) {
    if (evt.key === "Enter") {
      this.resolveAndClose(evt);
    }
  }
  resolveAndClose(evt) {
    this.submitted = true;
    evt.preventDefault();
    this.resolve(this.value);
    this.close();
  }
  async openAndGetValue(resolve, reject) {
    this.resolve = resolve;
    this.reject = reject;
    this.open();
  }
};

// src/url-utils.ts
var MarkdownUrlPattern = /\[([^\[\]]*)\]\((https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]+\.[^\s]{2,}|www\.[a-zA-Z0-9]+\.[^\s]{2,})\)/gi;
var UrlPattern = /(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]+\.[^\s]{2,}|www\.[a-zA-Z0-9]+\.[^\s]{2,})/gi;
function _cursorWithinBoundaries(cursorPosition, startIndex, length) {
  const endIndex = startIndex + length;
  return startIndex <= cursorPosition && cursorPosition <= endIndex;
}
function getUrlFromText(lineText, cursorPosition) {
  var _a, _b, _c, _d, _e, _f;
  const linksInLine = lineText.matchAll(MarkdownUrlPattern);
  for (const match of linksInLine) {
    if (_cursorWithinBoundaries(cursorPosition, (_a = match.index) != null ? _a : 0, match[0].length)) {
      return [(_b = match.index) != null ? _b : 0, ((_c = match.index) != null ? _c : 0) + match[0].length];
    }
  }
  const urlsInLine = lineText.matchAll(UrlPattern);
  for (const match of urlsInLine) {
    if (_cursorWithinBoundaries(cursorPosition, (_d = match.index) != null ? _d : 0, match[0].length)) {
      return [(_e = match.index) != null ? _e : 0, ((_f = match.index) != null ? _f : 0) + match[0].length];
    }
  }
  return [cursorPosition, cursorPosition];
}

// editor-extensions.ts
var EditorExtensions = class {
  static getSelectedText(editor) {
    if (!editor.somethingSelected()) {
      const wordBoundaries = this.getWordBoundaries(editor);
      editor.setSelection(wordBoundaries[0], wordBoundaries[1]);
    }
    return editor.getSelection();
  }
  static getWordBoundaries(editor) {
    const cursor = editor.getCursor();
    const lineText = editor.getLine(cursor.line);
    const urlPosition = getUrlFromText(lineText, cursor.ch);
    return [
      { line: cursor.line, ch: urlPosition[0] },
      { line: cursor.line, ch: urlPosition[1] }
    ];
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  timestampMod: 5,
  lang: "en",
  country: "EN",
  leafUrls: []
};
var YTranscriptPlugin = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerView(TRANSCRIPT_TYPE_VIEW, (leaf) => new TranscriptView(leaf, this));
    this.addCommand({
      id: "transcript-from-text",
      name: "Get YouTube transcript from selected url",
      editorCallback: (editor, _) => {
        const url = EditorExtensions.getSelectedText(editor).trim();
        this.openView(url);
      }
    });
    this.addCommand({
      id: "transcript-from-prompt",
      name: "Get YouTube transcript from url prompt",
      callback: async () => {
        const prompt = new PromptModal();
        const url = await new Promise((resolve) => prompt.openAndGetValue(resolve, () => {
        }));
        if (url) {
          this.openView(url);
        }
      }
    });
    this.addSettingTab(new YTranslateSettingTab(this.app, this));
  }
  async openView(url) {
    const leaf = this.app.workspace.getRightLeaf(false);
    await leaf.setViewState({
      type: TRANSCRIPT_TYPE_VIEW
    });
    this.app.workspace.revealLeaf(leaf);
    leaf.setEphemeralState({
      url
    });
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(TRANSCRIPT_TYPE_VIEW);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var YTranslateSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for YTranscript" });
    new import_obsidian4.Setting(containerEl).setName("Timestamp interval").setDesc("Indicates how often timestamp should occur in text (1 - every line, 10 - every 10 lines)").addText((text) => text.setValue(this.plugin.settings.timestampMod.toFixed()).onChange(async (value) => {
      const v = Number.parseInt(value);
      this.plugin.settings.timestampMod = Number.isNaN(v) ? 5 : v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Language").setDesc("Preferred transcript language").addText((text) => text.setValue(this.plugin.settings.lang).onChange(async (value) => {
      this.plugin.settings.lang = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Country").setDesc("Preferred transcript country code").addText((text) => text.setValue(this.plugin.settings.country).onChange(async (value) => {
      this.plugin.settings.country = value;
      await this.plugin.saveSettings();
    }));
  }
};
